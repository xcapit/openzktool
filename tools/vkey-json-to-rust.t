/**
 * --------------------------------------------------------------------------
 * vkey-json-to-rust.ts
 * --------------------------------------------------------------------------
 * Converts a verification key (vkey.json) generated by snarkjs into
 * Rust code snippets that can be pasted into the `vk()` function inside:
 *   soroban/src/lib.rs
 *
 * Usage:
 *   ts-node tools/vkey-json-to-rust.ts circuits/artifacts/kyc_transfer_vkey.json
 *
 * Example output:
 *   // alpha1
 *   let alfa1 = g1_from_u256(U256::from_be_bytes([...]), U256::from_be_bytes([...]));
 *
 *   // beta2
 *   let beta2 = { ... g2_from_u256(...) };
 *
 *   // IC points
 *   let ic: Vec<G1Affine> = vec![ g1_from_u256(...), ... ];
 *
 * --------------------------------------------------------------------------
 * Author: Xcapit Labs (Fernando Boiero)
 * License: AGPL-3.0-or-later
 * --------------------------------------------------------------------------
 */

import * as fs from "fs";

function hexToU256Tuple(hex: string): string {
  const h = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = Buffer.from(h.padStart(64, "0"), "hex");
  const byteList = Array.from(bytes).map((b) => b.toString());
  return `U256::from_be_bytes([${byteList.join(", ")}])`;
}

const filePath = process.argv[2];
if (!filePath) {
  console.error("Usage: ts-node tools/vkey-json-to-rust.ts <vkey.json>");
  process.exit(1);
}

const vkey = JSON.parse(fs.readFileSync(filePath, "utf8"));
const { alpha1, beta2, gamma2, delta2, IC } = vkey;

console.log("// alpha1");
console.log(
  `let alfa1 = g1_from_u256(${hexToU256Tuple(alpha1[0])}, ${hexToU256Tuple(
    alpha1[1]
  )});\n`
);

console.log("// beta2");
console.log(`let beta2 = {
  let x1 = ${hexToU256Tuple(beta2[0][0])};
  let x2 = ${hexToU256Tuple(beta2[0][1])};
  let y1 = ${hexToU256Tuple(beta2[1][0])};
  let y2 = ${hexToU256Tuple(beta2[1][1])};
  g2_from_u256(x1, x2, y1, y2)
};\n`);

console.log("// gamma2");
console.log(`let gamma2 = {
  let x1 = ${hexToU256Tuple(gamma2[0][0])};
  let x2 = ${hexToU256Tuple(gamma2[0][1])};
  let y1 = ${hexToU256Tuple(gamma2[1][0])};
  let y2 = ${hexToU256Tuple(gamma2[1][1])};
  g2_from_u256(x1, x2, y1, y2)
};\n`);

console.log("// delta2");
console.log(`let delta2 = {
  let x1 = ${hexToU256Tuple(delta2[0][0])};
  let x2 = ${hexToU256Tuple(delta2[0][1])};
  let y1 = ${hexToU256Tuple(delta2[1][0])};
  let y2 = ${hexToU256Tuple(delta2[1][1])};
  g2_from_u256(x1, x2, y1, y2)
};\n`);

console.log("// IC points");
console.log("let ic: Vec<G1Affine> = vec![");
for (const [x, y] of IC) {
  console.log(`  g1_from_u256(${hexToU256Tuple(x)}, ${hexToU256Tuple(y)}),`);
}
console.log("];");
