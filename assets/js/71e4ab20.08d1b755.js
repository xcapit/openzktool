"use strict";(globalThis.webpackChunkdocs_site=globalThis.webpackChunkdocs_site||[]).push([[151],{8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var i=r(6540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}},9850:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"api-reference/contract-api","title":"Soroban Contract API","description":"The OpenZKTool Groth16 verifier contract deployed on Stellar Soroban provides on-chain zero-knowledge proof verification.","source":"@site/docs/api-reference/contract-api.md","sourceDirName":"api-reference","slug":"/api-reference/contract-api","permalink":"/openzktool/docs/api-reference/contract-api","draft":false,"unlisted":false,"editUrl":"https://github.com/xcapit/openzktool/tree/main/docs-site/docs/api-reference/contract-api.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Command Line Interface","permalink":"/openzktool/docs/api-reference/cli"},"next":{"title":"Custom Circuits","permalink":"/openzktool/docs/advanced/custom-circuits"}}');var t=r(4848),s=r(8453);const o={sidebar_position:3},l="Soroban Contract API",c={},d=[{value:"Contract Address",id:"contract-address",level:2},{value:"Contract Interface",id:"contract-interface",level:2},{value:"<code>verify</code>",id:"verify",level:3},{value:"Function Signature",id:"function-signature",level:4},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Example Usage",id:"example-usage",level:4},{value:"Proof Format",id:"proof-format",level:2},{value:"Groth16 Proof Structure",id:"groth16-proof-structure",level:3},{value:"Serialization",id:"serialization",level:3},{value:"Public Inputs Format",id:"public-inputs-format",level:2},{value:"Verification Key Format",id:"verification-key-format",level:2},{value:"Gas Costs",id:"gas-costs",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Error Codes",id:"error-codes",level:3},{value:"Example Error Handling",id:"example-error-handling",level:3},{value:"Integration Patterns",id:"integration-patterns",level:2},{value:"Pattern 1: Stateless Verification",id:"pattern-1-stateless-verification",level:3},{value:"Pattern 2: Proof Caching",id:"pattern-2-proof-caching",level:3},{value:"Pattern 3: Batch Verification",id:"pattern-3-batch-verification",level:3},{value:"Deployment Guide",id:"deployment-guide",level:2},{value:"Deploy Your Own Verifier",id:"deploy-your-own-verifier",level:3},{value:"Deploy Output",id:"deploy-output",level:3},{value:"Testing",id:"testing",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"1. Proof Replay Attacks",id:"1-proof-replay-attacks",level:3},{value:"2. Front-Running",id:"2-front-running",level:3},{value:"3. DoS via Invalid Proofs",id:"3-dos-via-invalid-proofs",level:3},{value:"Monitoring &amp; Observability",id:"monitoring--observability",level:2},{value:"Event Logging",id:"event-logging",level:3},{value:"Metrics",id:"metrics",level:3},{value:"Next Steps",id:"next-steps",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"soroban-contract-api",children:"Soroban Contract API"})}),"\n",(0,t.jsx)(n.p,{children:"The OpenZKTool Groth16 verifier contract deployed on Stellar Soroban provides on-chain zero-knowledge proof verification."}),"\n",(0,t.jsx)(n.h2,{id:"contract-address",children:"Contract Address"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Stellar Testnet:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"CBPBVJJW5NMV4UVEDKSR6UO4DRBNWRQEMYKRYZI3CW6YK3O7HAZA43OI\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://stellar.expert/explorer/testnet/contract/CBPBVJJW5NMV4UVEDKSR6UO4DRBNWRQEMYKRYZI3CW6YK3O7HAZA43OI",children:"View on Stellar Expert \u2192"})}),"\n",(0,t.jsx)(n.h2,{id:"contract-interface",children:"Contract Interface"}),"\n",(0,t.jsx)(n.h3,{id:"verify",children:(0,t.jsx)(n.code,{children:"verify"})}),"\n",(0,t.jsx)(n.p,{children:"Verifies a Groth16 zero-knowledge proof."}),"\n",(0,t.jsx)(n.h4,{id:"function-signature",children:"Function Signature"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub fn verify(\n    env: Env,\n    proof: Vec<u8>,\n    public_inputs: Vec<u8>,\n    vk: VerificationKey\n) -> bool\n"})}),"\n",(0,t.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"env"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Env"})}),(0,t.jsx)(n.td,{children:"Soroban environment"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"proof"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Vec<u8>"})}),(0,t.jsx)(n.td,{children:"Serialized Groth16 proof"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"public_inputs"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Vec<u8>"})}),(0,t.jsx)(n.td,{children:"Public input signals"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"vk"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"VerificationKey"})}),(0,t.jsx)(n.td,{children:"Verification key structure"})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bool"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"true"})," if proof is valid, ",(0,t.jsx)(n.code,{children:"false"})," otherwise"]})]})})]}),"\n",(0,t.jsx)(n.h4,{id:"example-usage",children:"Example Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use soroban_sdk::{contract, contractimpl, Env, Vec, Bytes};\n\n#[contract]\npub struct MyDApp;\n\n#[contractimpl]\nimpl MyDApp {\n    pub fn check_kyc(env: Env, proof: Vec<u8>) -> bool {\n        let verifier_id = BytesN::from_array(\n            &env,\n            &hex!("CBPBVJJW5NMV4UVEDKSR6UO4DRBNWRQEMYKRYZI3CW6YK3O7HAZA43OI")\n        );\n\n        // Invoke the verifier contract\n        let result: bool = env.invoke_contract(\n            &verifier_id,\n            &symbol_short!("verify"),\n            (&proof,).into_val(&env)\n        );\n\n        result\n    }\n\n    pub fn gated_action(env: Env, user: Address, proof: Vec<u8>) {\n        // Require valid proof before allowing action\n        if !Self::check_kyc(env.clone(), proof) {\n            panic!("Invalid KYC proof");\n        }\n\n        // Proceed with action...\n        log!(&env, "KYC verified for user: {}", user);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"proof-format",children:"Proof Format"}),"\n",(0,t.jsx)(n.p,{children:"Proofs must be encoded in the following binary format:"}),"\n",(0,t.jsx)(n.h3,{id:"groth16-proof-structure",children:"Groth16 Proof Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"struct Proof {\n    a: G1Point,      // 64 bytes\n    b: G2Point,      // 128 bytes\n    c: G1Point,      // 64 bytes\n}\n\nstruct G1Point {\n    x: [u8; 32],    // Field element\n    y: [u8; 32],    // Field element\n}\n\nstruct G2Point {\n    x: ([u8; 32], [u8; 32]),  // Fq2 element\n    y: ([u8; 32], [u8; 32]),  // Fq2 element\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Total Proof Size:"})," 256 bytes (constant)"]}),"\n",(0,t.jsx)(n.h3,{id:"serialization",children:"Serialization"}),"\n",(0,t.jsx)(n.p,{children:"Proofs are serialized in big-endian format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[A.x (32 bytes)] [A.y (32 bytes)]\n[B.x.c0 (32)] [B.x.c1 (32)] [B.y.c0 (32)] [B.y.c1 (32)]\n[C.x (32 bytes)] [C.y (32 bytes)]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"public-inputs-format",children:"Public Inputs Format"}),"\n",(0,t.jsx)(n.p,{children:"Public inputs are encoded as field elements:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"struct PublicInputs {\n    signals: Vec<[u8; 32]>  // Each signal is 32 bytes\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"For the KYC circuit:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[kycValid (32 bytes)]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"verification-key-format",children:"Verification Key Format"}),"\n",(0,t.jsx)(n.p,{children:"The verification key contains cryptographic parameters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"struct VerificationKey {\n    alpha: G1Point,\n    beta: G2Point,\n    gamma: G2Point,\n    delta: G2Point,\n    ic: Vec<G1Point>,  // IC points for public inputs\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," The verification key is embedded in the contract during deployment."]}),"\n",(0,t.jsx)(n.h2,{id:"gas-costs",children:"Gas Costs"}),"\n",(0,t.jsx)(n.p,{children:"Approximate Soroban operation costs:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Operation"}),(0,t.jsx)(n.th,{children:"Gas (Operations)"}),(0,t.jsx)(n.th,{children:"Time"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Proof deserialization"}),(0,t.jsx)(n.td,{children:"~10,000"}),(0,t.jsx)(n.td,{children:"~10ms"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Pairing computation"}),(0,t.jsx)(n.td,{children:"~150,000"}),(0,t.jsx)(n.td,{children:"~150ms"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Final verification"}),(0,t.jsx)(n.td,{children:"~40,000"}),(0,t.jsx)(n.td,{children:"~40ms"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Total"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"~200,000"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"~200ms"})})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cost in XLM:"})," ~0.0002 XLM per verification (at current rates)"]}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"The contract returns errors for invalid inputs:"}),"\n",(0,t.jsx)(n.h3,{id:"error-codes",children:"Error Codes"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Code"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Resolution"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"InvalidProofFormat"})}),(0,t.jsx)(n.td,{children:"Proof serialization error"}),(0,t.jsx)(n.td,{children:"Check proof encoding"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"InvalidPublicInputs"})}),(0,t.jsx)(n.td,{children:"Public inputs mismatch"}),(0,t.jsx)(n.td,{children:"Verify input count/format"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"PairingCheckFailed"})}),(0,t.jsx)(n.td,{children:"Cryptographic verification failed"}),(0,t.jsx)(n.td,{children:"Regenerate proof"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"OutOfGas"})}),(0,t.jsx)(n.td,{children:"Insufficient gas provided"}),(0,t.jsx)(n.td,{children:"Increase gas limit"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"example-error-handling",children:"Example Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use soroban_sdk::{contractimpl, Env, Vec};\n\n#[contractimpl]\nimpl MyContract {\n    pub fn safe_verify(env: Env, proof: Vec<u8>) -> Result<bool, Error> {\n        let verifier = get_verifier_address();\n\n        match env.try_invoke_contract(&verifier, &symbol_short!("verify"), (&proof,)) {\n            Ok(result) => Ok(result),\n            Err(e) => {\n                log!(&env, "Verification failed: {}", e);\n                Err(Error::VerificationFailed)\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"integration-patterns",children:"Integration Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"pattern-1-stateless-verification",children:"Pattern 1: Stateless Verification"}),"\n",(0,t.jsx)(n.p,{children:"Verify proofs without storing any state:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[contractimpl]\nimpl Verifier {\n    pub fn verify_once(env: Env, proof: Vec<u8>) -> bool {\n        let verifier = get_verifier_id();\n        env.invoke_contract(&verifier, &symbol_short!("verify"), (&proof,))\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case:"})," One-time access checks"]}),"\n",(0,t.jsx)(n.h3,{id:"pattern-2-proof-caching",children:"Pattern 2: Proof Caching"}),"\n",(0,t.jsx)(n.p,{children:"Store verification results to avoid re-verification:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[contractimpl]\nimpl Verifier {\n    pub fn verify_and_cache(env: Env, user: Address, proof: Vec<u8>) -> bool {\n        // Check cache first\n        if let Some(cached) = env.storage().get(&user) {\n            return cached;\n        }\n\n        // Verify and cache\n        let result = Self::verify_once(env.clone(), proof);\n        env.storage().set(&user, &result);\n\n        result\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case:"})," Repeated access within a session"]}),"\n",(0,t.jsx)(n.h3,{id:"pattern-3-batch-verification",children:"Pattern 3: Batch Verification"}),"\n",(0,t.jsx)(n.p,{children:"Verify multiple proofs in a single transaction:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[contractimpl]\nimpl BatchVerifier {\n    pub fn verify_batch(env: Env, proofs: Vec<Vec<u8>>) -> Vec<bool> {\n        let verifier = get_verifier_id();\n        let mut results = Vec::new(&env);\n\n        for proof in proofs.iter() {\n            let valid: bool = env.invoke_contract(\n                &verifier,\n                &symbol_short!("verify"),\n                (&proof,)\n            );\n            results.push_back(valid);\n        }\n\n        results\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case:"})," Multi-user verification"]}),"\n",(0,t.jsx)(n.h2,{id:"deployment-guide",children:"Deployment Guide"}),"\n",(0,t.jsx)(n.h3,{id:"deploy-your-own-verifier",children:"Deploy Your Own Verifier"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Build the contract\ncd contracts\ncargo build --target wasm32-unknown-unknown --release\n\n# Optimize WASM\nwasm-opt --strip-debug -Oz \\\n  target/wasm32-unknown-unknown/release/verifier.wasm \\\n  -o verifier-optimized.wasm\n\n# Deploy to Soroban\nsoroban contract deploy \\\n  --wasm verifier-optimized.wasm \\\n  --source YOUR_SECRET_KEY \\\n  --network testnet\n"})}),"\n",(0,t.jsx)(n.h3,{id:"deploy-output",children:"Deploy Output"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Contract deployed successfully!\nContract ID: YOUR_CONTRACT_ID\nTransaction: https://stellar.expert/explorer/testnet/tx/HASH\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,t.jsx)(n.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"#[test]\nfn test_valid_proof() {\n    let env = Env::default();\n    let contract = VerifierClient::new(&env, &contract_id);\n\n    let proof = generate_test_proof();\n    let result = contract.verify(&proof);\n\n    assert_eq!(result, true);\n}\n\n#[test]\nfn test_invalid_proof() {\n    let env = Env::default();\n    let contract = VerifierClient::new(&env, &contract_id);\n\n    let invalid_proof = vec![0u8; 256];\n    let result = contract.verify(&invalid_proof);\n\n    assert_eq!(result, false);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Test on testnet\nnpm run test:integration\n"})}),"\n",(0,t.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"1-proof-replay-attacks",children:"1. Proof Replay Attacks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Same proof can be used multiple times."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution:"})," Add nonce or timestamp to public inputs:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub fn verify_with_nonce(env: Env, proof: Vec<u8>, nonce: u64) -> bool {\n    // Check nonce hasn't been used\n    if env.storage().has(&nonce) {\n        return false;\n    }\n\n    let valid = verify(env.clone(), proof);\n\n    if valid {\n        env.storage().set(&nonce, &true);\n    }\n\n    valid\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-front-running",children:"2. Front-Running"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Attacker sees proof in mempool and submits it first."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution:"})," Bind proof to sender address:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub fn verify_for_sender(env: Env, proof: Vec<u8>) -> bool {\n    let sender = env.invoker();\n\n    // Proof must include sender in public inputs\n    let valid = verify_with_sender(env, proof, sender);\n\n    valid\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-dos-via-invalid-proofs",children:"3. DoS via Invalid Proofs"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Problem:"})," Spamming invalid proofs wastes gas."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution:"})," Implement rate limiting:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'pub fn verify_with_rate_limit(env: Env, user: Address, proof: Vec<u8>) -> bool {\n    let attempts = env.storage().get::<_, u32>(&user).unwrap_or(0);\n\n    if attempts >= MAX_ATTEMPTS {\n        panic!("Rate limit exceeded");\n    }\n\n    let valid = verify(env.clone(), proof);\n\n    if !valid {\n        env.storage().set(&user, &(attempts + 1));\n    }\n\n    valid\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"monitoring--observability",children:"Monitoring & Observability"}),"\n",(0,t.jsx)(n.h3,{id:"event-logging",children:"Event Logging"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'#[contractimpl]\nimpl Verifier {\n    pub fn verify_with_logs(env: Env, proof: Vec<u8>) -> bool {\n        log!(&env, "Verification started");\n\n        let start = env.ledger().timestamp();\n        let result = verify(env.clone(), proof);\n        let duration = env.ledger().timestamp() - start;\n\n        log!(&env, "Verification completed: {} ({}ms)", result, duration);\n\n        env.events().publish(\n            (symbol_short!("verify"),),\n            (result, duration)\n        );\n\n        result\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"metrics",children:"Metrics"}),"\n",(0,t.jsx)(n.p,{children:"Track verification metrics:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"struct Metrics {\n    total_verifications: u64,\n    successful_verifications: u64,\n    failed_verifications: u64,\n    average_gas_used: u64,\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./cli",children:"CLI Reference \u2192"})})," - Command line tools"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"../stellar-integration/deployment",children:"Deployment Guide \u2192"})})," - Deploy your own verifier"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"../advanced/custom-circuits",children:"Advanced Topics \u2192"})})," - Custom circuit development"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Need help?"})," ",(0,t.jsx)(n.a,{href:"https://github.com/xcapit/openzktool/discussions",children:"GitHub Discussions"})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);