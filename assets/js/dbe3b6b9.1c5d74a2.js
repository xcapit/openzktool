"use strict";(globalThis.webpackChunkdocs_site=globalThis.webpackChunkdocs_site||[]).push([[438],{3597:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"advanced/best-practices","title":"Best Practices","description":"Production-ready patterns and security guidelines for building with OpenZKTool.","source":"@site/docs/advanced/best-practices.md","sourceDirName":"advanced","slug":"/advanced/best-practices","permalink":"/openzktool/docs/advanced/best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/xcapit/openzktool/tree/main/docs-site/docs/advanced/best-practices.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Custom Circuits","permalink":"/openzktool/docs/advanced/custom-circuits"},"next":{"title":"Examples & Tutorials","permalink":"/openzktool/docs/examples/"}}');var i=r(4848),o=r(8453);const s={sidebar_position:2},a="Best Practices",c={},l=[{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"Never Expose Private Inputs",id:"never-expose-private-inputs",level:3},{value:"Validate Public Inputs",id:"validate-public-inputs",level:3},{value:"Verify Proofs On-Chain",id:"verify-proofs-on-chain",level:3},{value:"Protect Against Proof Replay",id:"protect-against-proof-replay",level:3},{value:"Secure Key Management",id:"secure-key-management",level:3},{value:"Performance Best Practices",id:"performance-best-practices",level:2},{value:"Preload Circuit Files",id:"preload-circuit-files",level:3},{value:"Use Web Workers (Browser)",id:"use-web-workers-browser",level:3},{value:"Batch Verifications",id:"batch-verifications",level:3},{value:"Cache Verification Results",id:"cache-verification-results",level:3},{value:"Error Handling Best Practices",id:"error-handling-best-practices",level:2},{value:"Comprehensive Error Handling",id:"comprehensive-error-handling",level:3},{value:"Retry Logic for Network Failures",id:"retry-logic-for-network-failures",level:3},{value:"Testing Best Practices",id:"testing-best-practices",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"Deployment Best Practices",id:"deployment-best-practices",level:2},{value:"Environment Configuration",id:"environment-configuration",level:3},{value:"Monitoring &amp; Logging",id:"monitoring--logging",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"Architecture Patterns",id:"architecture-patterns",level:2},{value:"Microservices Architecture",id:"microservices-architecture",level:3},{value:"Serverless Architecture",id:"serverless-architecture",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"best-practices",children:"Best Practices"})}),"\n",(0,i.jsx)(n.p,{children:"Production-ready patterns and security guidelines for building with OpenZKTool."}),"\n",(0,i.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"never-expose-private-inputs",children:"Never Expose Private Inputs"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\u274c WRONG: Sending private data to server"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// DON'T DO THIS!\nasync function badExample(userData) {\n  // Sending private data to backend - PRIVACY VIOLATION!\n  const response = await fetch('/api/verify', {\n    method: 'POST',\n    body: JSON.stringify({\n      age: userData.age,         // Private! Should NEVER leave client\n      balance: userData.balance, // Private! Should NEVER leave client\n      country: userData.country  // Private! Should NEVER leave client\n    })\n  });\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\u2705 CORRECT: Generate proof on client"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// DO THIS INSTEAD\nasync function goodExample(userData) {\n  // Generate proof on CLIENT SIDE (browser/mobile app)\n  const generator = new ProofGenerator();\n  const proof = await generator.generate(userData);\n\n  // Only send the PROOF (which reveals nothing about private data)\n  const response = await fetch('/api/verify', {\n    method: 'POST',\n    body: JSON.stringify({\n      proof: proof  // Safe to send - reveals nothing!\n    })\n  });\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why this matters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Proof generation MUST happen on the user's device"}),"\n",(0,i.jsx)(n.li,{children:"Private inputs (age, balance, country) NEVER leave the device"}),"\n",(0,i.jsx)(n.li,{children:"Only the proof (which reveals nothing) is transmitted"}),"\n",(0,i.jsx)(n.li,{children:"This is the core privacy guarantee of zero-knowledge proofs"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"validate-public-inputs",children:"Validate Public Inputs"}),"\n",(0,i.jsx)(n.p,{children:"Always validate that public inputs match your application's requirements:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function validatePublicInputs(minAge, maxAge, minBalance, allowedCountries) {\n  // Ensure age range is reasonable\n  if (minAge < 0 || minAge > 150) {\n    throw new Error('Invalid minAge');\n  }\n  if (maxAge < minAge || maxAge > 150) {\n    throw new Error('Invalid maxAge');\n  }\n\n  // Ensure balance threshold is non-negative\n  if (minBalance < 0) {\n    throw new Error('Invalid minBalance');\n  }\n\n  // Ensure exactly 10 country codes\n  if (allowedCountries.length !== 10) {\n    throw new Error('allowedCountries must have exactly 10 elements');\n  }\n\n  // Ensure all country codes are in valid range\n  for (const code of allowedCountries) {\n    if (code < 0 || code > 999) {\n      throw new Error('Invalid country code');\n    }\n  }\n\n  return true;\n}\n\n// Use before generating proofs\nvalidatePublicInputs(18, 99, 100, [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"verify-proofs-on-chain",children:"Verify Proofs On-Chain"}),"\n",(0,i.jsx)(n.p,{children:"For critical applications, always verify proofs on-chain:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c WRONG: Trusting client-side verification\nasync function insecureFlow(proof) {\n  // Local verification can be faked by modified client!\n  const verifier = new ProofVerifier();\n  const isValid = await verifier.verify(proof);\n\n  if (isValid) {\n    // Granting access based on LOCAL verification - INSECURE!\n    await grantPremiumAccess(userId);\n  }\n}\n\n// \u2705 CORRECT: On-chain verification\nasync function secureFlow(proof) {\n  // Verify on Stellar Soroban - tamper-proof!\n  const verifier = new SorobanVerifier({\n    contractId: CONTRACT_ID,\n    network: 'mainnet',\n    secretKey: SERVER_SECRET_KEY\n  });\n\n  const result = await verifier.submit(proof);\n\n  if (result.success && result.result === true) {\n    // Now safe to grant access - blockchain verified!\n    await grantPremiumAccess(userId, result.txHash);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"protect-against-proof-replay",children:"Protect Against Proof Replay"}),"\n",(0,i.jsx)(n.p,{children:"Prevent reuse of the same proof across different users:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Add user-specific binding to public inputs\nasync function generateBoundProof(userData, userId) {\n  const generator = new ProofGenerator();\n\n  // Hash userId into one of the public inputs\n  const userHash = hashUserId(userId);\n\n  const proof = await generator.generate({\n    ...userData,\n    // Bind proof to specific user (example: use first allowed country slot)\n    allowedCountries: [userHash % 1000, 2, 3, 0, 0, 0, 0, 0, 0, 0]\n  });\n\n  return proof;\n}\n\n// Verification checks the binding\nasync function verifyBoundProof(proof, userId) {\n  const userHash = hashUserId(userId);\n\n  // Ensure proof was generated for THIS user\n  // (Implementation depends on how you encode the binding)\n\n  const verifier = new SorobanVerifier({...});\n  return await verifier.verify(proof);\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"secure-key-management",children:"Secure Key Management"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For Development:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Use environment variables\nexport STELLAR_SECRET_KEY="SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"\nexport CONTRACT_ID="CBPBVJJW5NMV4UVEDKSR6UO4DRBNWRQEMYKRYZI3CW6YK3O7HAZA43OI"\n\n# Never commit secrets to git\necho ".env" >> .gitignore\necho "*.key" >> .gitignore\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For Production:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// Use secure secret management service\nimport { SecretManagerServiceClient } from '@google-cloud/secret-manager';\n\nasync function getSecret(name) {\n  const client = new SecretManagerServiceClient();\n  const [version] = await client.accessSecretVersion({\n    name: `projects/my-project/secrets/${name}/versions/latest`,\n  });\n  return version.payload.data.toString();\n}\n\nconst SECRET_KEY = await getSecret('stellar-secret-key');\nconst CONTRACT_ID = await getSecret('verifier-contract-id');\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-best-practices",children:"Performance Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"preload-circuit-files",children:"Preload Circuit Files"}),"\n",(0,i.jsx)(n.p,{children:"Avoid loading WASM files on every proof generation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c SLOW: Loading WASM each time\nasync function slowProofGeneration(input) {\n  const generator = new ProofGenerator();  // Loads WASM\n  return await generator.generate(input);   // Generates proof\n}\n\n// \u2705 FAST: Preload once, reuse many times\nconst generator = new ProofGenerator();\nawait generator.preload();  // Load WASM once at startup\n\nasync function fastProofGeneration(input) {\n  return await generator.generate(input);  // Only generates proof\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Performance improvement:"})," 2-3x faster for subsequent proofs"]}),"\n",(0,i.jsx)(n.h3,{id:"use-web-workers-browser",children:"Use Web Workers (Browser)"}),"\n",(0,i.jsx)(n.p,{children:"Offload proof generation to prevent UI blocking:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// proof-worker.js\nimport { ProofGenerator } from 'openzktool';\n\nconst generator = new ProofGenerator();\nawait generator.preload();\n\nself.addEventListener('message', async (event) => {\n  const { userData } = event.data;\n\n  try {\n    const proof = await generator.generate(userData);\n    self.postMessage({ success: true, proof });\n  } catch (error) {\n    self.postMessage({ success: false, error: error.message });\n  }\n});\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// main.js\nconst worker = new Worker('proof-worker.js');\n\nfunction generateProofAsync(userData) {\n  return new Promise((resolve, reject) => {\n    worker.onmessage = (event) => {\n      if (event.data.success) {\n        resolve(event.data.proof);\n      } else {\n        reject(new Error(event.data.error));\n      }\n    };\n\n    worker.postMessage({ userData });\n  });\n}\n\n// UI stays responsive during proof generation!\nconst proof = await generateProofAsync(userData);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"batch-verifications",children:"Batch Verifications"}),"\n",(0,i.jsx)(n.p,{children:"Verify multiple proofs in parallel:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// \u274c SLOW: Sequential verification\nasync function slowBatchVerify(proofs) {\n  const results = [];\n  for (const proof of proofs) {\n    const isValid = await verifier.verify(proof);\n    results.push(isValid);\n  }\n  return results;\n}\n\n// \u2705 FAST: Parallel verification\nasync function fastBatchVerify(proofs) {\n  const results = await Promise.all(\n    proofs.map(proof => verifier.verify(proof))\n  );\n  return results;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Performance improvement:"})," N times faster for N proofs"]}),"\n",(0,i.jsx)(n.h3,{id:"cache-verification-results",children:"Cache Verification Results"}),"\n",(0,i.jsx)(n.p,{children:"For proofs that don't change, cache verification results:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const verificationCache = new Map();\n\nasync function verifyWithCache(proof) {\n  const proofHash = hashProof(proof);\n\n  if (verificationCache.has(proofHash)) {\n    return verificationCache.get(proofHash);\n  }\n\n  const isValid = await verifier.verify(proof);\n  verificationCache.set(proofHash, isValid);\n\n  return isValid;\n}\n\nfunction hashProof(proof) {\n  return crypto\n    .createHash('sha256')\n    .update(JSON.stringify(proof))\n    .digest('hex');\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-best-practices",children:"Error Handling Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"comprehensive-error-handling",children:"Comprehensive Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { ProofGenerator, ProofError } from 'openzktool';\n\nasync function robustProofGeneration(userData) {\n  try {\n    const generator = new ProofGenerator();\n    const proof = await generator.generate(userData);\n\n    return {\n      success: true,\n      proof,\n      kycValid: proof.publicSignals[0] === '1'\n    };\n\n  } catch (error) {\n    if (error instanceof ProofError) {\n      switch (error.code) {\n        case 'CONSTRAINT_VIOLATION':\n          // User's data doesn't meet requirements\n          return {\n            success: false,\n            error: 'Requirements not met',\n            details: {\n              age: userData.age < userData.minAge || userData.age > userData.maxAge,\n              balance: userData.balance < userData.minBalance,\n              country: !userData.allowedCountries.includes(userData.country)\n            }\n          };\n\n        case 'INVALID_INPUT':\n          // Input format is wrong\n          return {\n            success: false,\n            error: 'Invalid input format',\n            message: error.message\n          };\n\n        case 'MISSING_FILES':\n          // Circuit files not found\n          return {\n            success: false,\n            error: 'System not configured',\n            files: error.files\n          };\n\n        default:\n          // Unknown error\n          console.error('Unknown proof error:', error);\n          return {\n            success: false,\n            error: 'Proof generation failed'\n          };\n      }\n    } else {\n      // Non-proof error\n      console.error('Unexpected error:', error);\n      return {\n        success: false,\n        error: 'Unexpected error occurred'\n      };\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"retry-logic-for-network-failures",children:"Retry Logic for Network Failures"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"async function verifyWithRetry(proof, maxRetries = 3) {\n  let lastError;\n\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      const result = await verifier.submit(proof);\n      return result;\n    } catch (error) {\n      lastError = error;\n\n      // Only retry on network errors, not invalid proofs\n      if (error.message.includes('network') || error.message.includes('timeout')) {\n        console.log(`Retry ${i + 1}/${maxRetries}...`);\n        await sleep(1000 * Math.pow(2, i));  // Exponential backoff\n        continue;\n      } else {\n        // Don't retry for other errors (e.g., invalid proof)\n        throw error;\n      }\n    }\n  }\n\n  throw new Error(`Failed after ${maxRetries} retries: ${lastError.message}`);\n}\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"testing-best-practices",children:"Testing Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { describe, it, expect, beforeAll } from 'vitest';\nimport { ProofGenerator, ProofVerifier } from 'openzktool';\n\ndescribe('KYC Proof System', () => {\n  let generator, verifier;\n\n  beforeAll(async () => {\n    generator = new ProofGenerator();\n    verifier = new ProofVerifier();\n    await generator.preload();  // Speed up tests\n  });\n\n  describe('Valid proofs', () => {\n    it('should accept eligible user (all checks pass)', async () => {\n      const proof = await generator.generate({\n        age: 25,\n        balance: 1000,\n        country: 1,\n        minAge: 18,\n        maxAge: 99,\n        minBalance: 100,\n        allowedCountries: [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]\n      });\n\n      expect(proof.publicSignals[0]).toBe('1');\n      const isValid = await verifier.verify(proof);\n      expect(isValid).toBe(true);\n    });\n\n    it('should accept user at minimum age boundary', async () => {\n      const proof = await generator.generate({\n        age: 18,  // Exactly minimum\n        balance: 1000,\n        country: 1,\n        minAge: 18,\n        maxAge: 99,\n        minBalance: 100,\n        allowedCountries: [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]\n      });\n\n      expect(proof.publicSignals[0]).toBe('1');\n    });\n  });\n\n  describe('Invalid proofs', () => {\n    it('should reject underage user', async () => {\n      const proof = await generator.generate({\n        age: 17,  // Below minimum\n        balance: 1000,\n        country: 1,\n        minAge: 18,\n        maxAge: 99,\n        minBalance: 100,\n        allowedCountries: [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]\n      });\n\n      expect(proof.publicSignals[0]).toBe('0');\n    });\n\n    it('should reject insufficient balance', async () => {\n      const proof = await generator.generate({\n        age: 25,\n        balance: 99,  // Below minimum\n        country: 1,\n        minAge: 18,\n        maxAge: 99,\n        minBalance: 100,\n        allowedCountries: [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]\n      });\n\n      expect(proof.publicSignals[0]).toBe('0');\n    });\n\n    it('should reject disallowed country', async () => {\n      const proof = await generator.generate({\n        age: 25,\n        balance: 1000,\n        country: 99,  // Not in allowed list\n        minAge: 18,\n        maxAge: 99,\n        minBalance: 100,\n        allowedCountries: [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]\n      });\n\n      expect(proof.publicSignals[0]).toBe('0');\n    });\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"describe('Soroban Integration', () => {\n  let generator, verifier;\n\n  beforeAll(() => {\n    generator = new ProofGenerator();\n    verifier = new SorobanVerifier({\n      contractId: process.env.TEST_CONTRACT_ID,\n      network: 'testnet',\n      secretKey: process.env.TEST_SECRET_KEY\n    });\n  });\n\n  it('should verify valid proof on-chain', async () => {\n    const proof = await generator.generate({\n      age: 25,\n      balance: 1000,\n      country: 1,\n      minAge: 18,\n      maxAge: 99,\n      minBalance: 100,\n      allowedCountries: [1, 2, 3, 0, 0, 0, 0, 0, 0, 0]\n    });\n\n    const result = await verifier.submit(proof);\n\n    expect(result.success).toBe(true);\n    expect(result.result).toBe(true);\n    expect(result.txHash).toBeDefined();\n  });\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"deployment-best-practices",children:"Deployment Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"environment-configuration",children:"Environment Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# .env.development\nNODE_ENV=development\nSTELLAR_NETWORK=testnet\nSTELLAR_SECRET_KEY=STEST...\nCONTRACT_ID=CTEST...\nDEBUG=true\n\n# .env.production\nNODE_ENV=production\nSTELLAR_NETWORK=mainnet\nSTELLAR_SECRET_KEY=SPROD...\nCONTRACT_ID=CPROD...\nDEBUG=false\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// config.js\nexport const config = {\n  network: process.env.STELLAR_NETWORK || 'testnet',\n  secretKey: process.env.STELLAR_SECRET_KEY,\n  contractId: process.env.CONTRACT_ID,\n  debug: process.env.DEBUG === 'true',\n\n  // Circuit paths\n  circuitWasm: process.env.CIRCUIT_WASM || './circuits/build/kyc_transfer.wasm',\n  circuitZkey: process.env.CIRCUIT_ZKEY || './circuits/build/kyc_transfer_final.zkey',\n  verificationKey: process.env.VERIFICATION_KEY || './circuits/build/verification_key.json'\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"monitoring--logging",children:"Monitoring & Logging"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { ProofGenerator } from 'openzktool';\nimport * as Sentry from '@sentry/node';\n\nasync function monitoredProofGeneration(userData) {\n  const startTime = Date.now();\n\n  try {\n    const generator = new ProofGenerator();\n    const proof = await generator.generate(userData);\n\n    const duration = Date.now() - startTime;\n\n    // Log metrics\n    console.log('Proof generated', {\n      duration,\n      kycValid: proof.publicSignals[0] === '1',\n      proofSize: JSON.stringify(proof).length\n    });\n\n    // Send to monitoring service\n    metrics.histogram('proof.generation.duration', duration);\n    metrics.increment('proof.generation.success');\n\n    return proof;\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n\n    // Log error\n    console.error('Proof generation failed', {\n      duration,\n      error: error.message,\n      stack: error.stack\n    });\n\n    // Send to error tracking\n    Sentry.captureException(error);\n    metrics.increment('proof.generation.error');\n\n    throw error;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import rateLimit from 'express-rate-limit';\n\n// Limit proof generation requests\nconst proofLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 10, // Max 10 proofs per 15 minutes per IP\n  message: 'Too many proof generation requests, please try again later.',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.post('/api/proof/generate', proofLimiter, async (req, res) => {\n  // Handle proof generation\n});\n\n// Limit verification requests\nconst verifyLimiter = rateLimit({\n  windowMs: 1 * 60 * 1000, // 1 minute\n  max: 30, // Max 30 verifications per minute per IP\n  message: 'Too many verification requests, please try again later.'\n});\n\napp.post('/api/proof/verify', verifyLimiter, async (req, res) => {\n  // Handle verification\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"architecture-patterns",children:"Architecture Patterns"}),"\n",(0,i.jsx)(n.h3,{id:"microservices-architecture",children:"Microservices Architecture"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Client    \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Proof Service   \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Soroban    \u2502\n\u2502  (Browser)  \u2502      \u2502   (Node.js API)  \u2502      \u2502  Verifier   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2502                       \u2502\n      \u2502                       \u25bc\n      \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Static Assets   \u2502\n                     \u2502   (CDN/IPFS)     \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Client generates proofs (privacy preserved)"}),"\n",(0,i.jsx)(n.li,{children:"Backend only handles verification"}),"\n",(0,i.jsx)(n.li,{children:"Scalable verification service"}),"\n",(0,i.jsx)(n.li,{children:"Circuit files served from CDN"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"serverless-architecture",children:"Serverless Architecture"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// AWS Lambda handler\nexport const handler = async (event) => {\n  const { proof } = JSON.parse(event.body);\n\n  const verifier = new SorobanVerifier({\n    contractId: process.env.CONTRACT_ID,\n    network: 'mainnet'\n  });\n\n  try {\n    const isValid = await verifier.verify(proof);\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify({ valid: isValid })\n    };\n  } catch (error) {\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ error: error.message })\n    };\n  }\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"./security",children:"Security Guide \u2192"})})," - Comprehensive security practices"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"./monitoring",children:"Monitoring \u2192"})})," - Production monitoring setup"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"./custom-circuits",children:"Custom Circuits \u2192"})})," - Build custom circuits"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Questions?"})," ",(0,i.jsx)(n.a,{href:"https://github.com/xcapit/openzktool/discussions",children:"GitHub Discussions"})]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(6540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);